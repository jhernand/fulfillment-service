#
# Copyright (c) 2025 Red Hat Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
# the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
# specific language governing permissions and limitations under the License.
#

apiVersion: authorino.kuadrant.io/v1beta3
kind: AuthConfig
metadata:
  name: fulfillment-service
spec:
  hosts:
  - "*"
  authentication:
    "fulfillment-api":
      kubernetesTokenReview:
        audiences:
        # TODO: This is the default audience for the Kubernetes API server. We should probably create a custom audience,
        # for example `fulfillment-api`, but then the users will need to create tokens for that audience. For example:
        #
        # $ kubectl create token -n innabox --audience=fulfillment-api client
        #
        # It is not clear to me if we can also use that audience for the tokens generated automatically for the service
        # accounts of other pods, for example for the `controller` pods. It may be possible using a projected service
        # account token, something like this:
        #
        # apiVersion: v1
        # kind: Pod
        # metadata:
        #   name: my
        # spec:
        #   containers:
        #   - volumeMounts:
        #     - mountPath: /var/run/secrets/tokens
        #       name: api-token
        #   volumes:
        #   - name: api-token
        #     projected:
        #       sources:
        #       - serviceAccountToken:
        #           path: api-token
        #           audience: fulfillment-api
        #
        # But that needs to be tested.
        - https://kubernetes.default.svc.cluster.local
  authorization:
    "fulfillment-api":
      opa:
        rego: |
          import future.keywords.in

          # Define service accounts:
          client_accounts := {
            "system:serviceaccount:innabox:client",
          }

          admin_accounts := {
            "system:serviceaccount:innabox:admin",
            "system:serviceaccount:innabox:controller",
          }

          # Get the gRPC method:
          grpc_method := input.context.request.http.path

          # Get the account name:
          account_name := input.auth.identity.user.username

          # Allow reflection and health to everyone:
          allow {
            startswith(grpc_method, "/grpc.reflection.")
          }

          allow {
            startswith(grpc_method, "/grpc.health.")
          }

          # Allow specific methods to clients:
          allow {
            grpc_method in {
              "/events.v1/Watch",
              "/fulfillment.v1.ClusterTemplates/Get",
              "/fulfillment.v1.ClusterTemplates/List",
              "/fulfillment.v1.Clusters/Create",
              "/fulfillment.v1.Clusters/Delete",
              "/fulfillment.v1.Clusters/Get",
              "/fulfillment.v1.Clusters/GetKubeconfig",
              "/fulfillment.v1.Clusters/GetKubeconfigViaHttp",
              "/fulfillment.v1.Clusters/GetPassword",
              "/fulfillment.v1.Clusters/GetPasswordViaHttp",
              "/fulfillment.v1.Clusters/List",
              "/fulfillment.v1.Clusters/Update",
              "/fulfillment.v1.HostClasses/Get",
              "/fulfillment.v1.HostClasses/List",
            }
            account_name in client_accounts
          }

          # Allow everything to admin and controller:
          allow {
            account_name in admin_accounts
          }
  response:
    success:
      headers:
        "x-subject":
          json:
            properties:
              user:
                selector: auth.identity.user.username
              groups:
                selector: auth.identity.user.groups
