{{/*
Copyright (c) 2025 Red Hat Inc.

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
the License. You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.
*/}}

apiVersion: authorino.kuadrant.io/v1beta3
kind: AuthConfig
metadata:
  namespace: {{ .Release.Namespace }}
  name: fulfillment-service
spec:
  hosts:
  - "*"
  authentication:
    "fulfillment-api":
      kubernetesTokenReview:
        audiences:
        # TODO: This is the default audience for the Kubernetes API server. We should probably create a custom audience,
        # for example `fulfillment-api`, but then the users will need to create tokens for that audience. For example:
        #
        # $ kubectl create token -n innabox --audience=fulfillment-api client
        #
        # It is not clear to me if we can also use that audience for the tokens generated automatically for the service
        # accounts of other pods, for example for the `controller` pods. It may be possible using a projected service
        # account token, something like this:
        #
        # apiVersion: v1
        # kind: Pod
        # metadata:
        #   name: my
        # spec:
        #   containers:
        #   - volumeMounts:
        #     - mountPath: /var/run/secrets/tokens
        #       name: api-token
        #   volumes:
        #   - name: api-token
        #     projected:
        #       sources:
        #       - serviceAccountToken:
        #           path: api-token
        #           audience: fulfillment-api
        #
        # But that needs to be tested.
        #
        # Note also that different flavours of Kubernetes use different audicences for the service account tokens. Kind
        # uses the full DNS name `kubernetes.default.svc.cluster.local`, but OpenShift uses the `kubernetes.default.svc`
        # abbreviation.
        - https://kubernetes.default.svc
        - https://kubernetes.default.svc.cluster.local
      overrides:
        authnMethod:
          value: serviceaccount
    "keycloak-jwt":
      jwt:
        issuerUrl: {{ required "auth.issuerUrl is required" .Values.auth.issuerUrl }}
      overrides:
        authnMethod:
          value: jwt
  authorization:
    "fulfillment-api":
      opa:
        rego: |
          allow {
            true
          }
  response:
    success:
      headers:
        "x-subject":
          json:
            properties:
              source:
                expression: |
                  auth.identity.authnMethod
              user:
                expression: |
                  auth.identity.authnMethod == "serviceaccount"? auth.identity.user.username: auth.identity.username
              groups:
                expression: |
                  auth.identity.authnMethod == "serviceaccount"? auth.identity.user.groups: auth.identity.groups
